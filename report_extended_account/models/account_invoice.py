# -*- coding: utf-8 -*-
##############################################################################
#
#    Ingenieria ADHOC - ADHOC SA
#    https://launchpad.net/~ingenieria-adhoc
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

from openerp.osv import osv, fields
from openerp.tools.translate import _

class account_invoice(osv.osv):
    _inherit = 'account.invoice'
    
    _columns = {
        'splitter_invoice_id': fields.many2one('account.invoice', 'Splitter Invoice',
                    help='This field contain the invoice that was splitted, generating another invoice.'),
        'splitted_invoice_id': fields.many2one('account.invoice', 'Generated Invoice',
                    help='This field contain the invoice generated by splitting the current one.'),
    }
    
    def invoice_print(self, cr, uid, ids, context=None):
        '''
        This function prints the invoice and mark it as sent, so that we can see more easily the next step of the workflow
        '''
        report_obj = self.pool.get('ir.actions.report.xml')
        report_name = report_obj.get_report_name(cr, uid, 'account.invoice', ids, context=context)

        # Esto es para marcarla como enviada
        assert len(ids) == 1, 'This option should only be used for a single id at a time.'
        self.write(cr, uid, ids, {'sent': True}, context=context)
            
        return self.pool['report'].get_action(cr, uid, ids, report_name, context=context)

    def copy(self, cr, uid, id, default=None, context=None):
        '''
        When an Invoice is copied the splitter and splitted invoices is not copy.
        '''
        if default is None:
            default = {}
        default['splitter_invoice_id'] = None
        default['splitted_invoice_id'] = None
        return super(account_invoice, self).copy(cr, uid, id, default=default, context=context)
    
    def split_invoice(self, cr, uid, ids, lines_to_split, context=None):
        '''
        Split the invoice when the lines exceed the maximum lines_to_split
        '''
        if not lines_to_split:
            return
        
        sale_order_obj = self.pool.get('sale.order')
        
        for inv in self.browse(cr, uid, ids, context=None):
            inv_id = False
            
            if inv.type in ["out_invoice","out_refund"]:
                
                if len(inv.invoice_line) > lines_to_split:
                    lst = []
                    invoice = self.read(cr, uid, inv.id, ['name', 'type', 'number', 'reference', 'comment', 'date_due', 'partner_id', 'partner_contact', 'partner_insite', 'partner_ref', 'payment_term', 'account_id', 'currency_id', 'invoice_line', 'tax_line', 'journal_id', 'period_id', 'company_id', 'origin', 'user_id'])
                    # invoice = self.read(cr, uid, inv.id, ['name', 'type', 'number', 'reference', 'comment', 'date_due', 'partner_id', 'partner_contact', 'partner_insite', 'partner_ref', 'payment_term', 'account_id', 'currency_id', 'invoice_line', 'tax_line', 'journal_id', 'period_id', 'company_id', 'origin', 'user_id'])
                    invoice.update({
                        'state': 'draft',
                        'number': False,
                        'invoice_line': [],
                        'tax_line': [],
                        'splitter_invoice_id': inv.id,
                    })
                    
                    print 'invoice', invoice                    
                    # take the id part of the tuple returned for many2one fields
                    for field in ('partner_id','account_id', 'currency_id', 'payment_term', 'journal_id', 'period_id', 'company_id', 'user_id'):
                        invoice[field] = invoice[field] and invoice[field][0]
                    
                    # if hasattr(inv, 'sale_ids'):
                    #     print 'inv', inv
                    #     if self.browse(cr, uid, inv.id, context={}).sale_ids:
                    #         invoice.update({
                    #             'sale_ids':[(6,0,[i.id for i in self.browse(cr, uid, inv.id, context={}).sale_ids])]
                    #         })
                    #     print 'invoice', invoice
                        
                    inv_id = self.create(cr, uid, invoice)
                    cont = 0
                    lst = inv.invoice_line
                    while cont < lines_to_split:
                        lst.pop(0)
                        cont += 1
                    for il in lst:
                        self.pool.get('account.invoice.line').write(cr,uid,il.id,{'invoice_id': inv_id})
                    
                    self.write(cr, uid, inv.id, {'splitted_invoice_id': inv_id}, context=context)
                    
                    self.button_compute(cr, uid, [inv.id], set_total=True)
                    
                    sale_order_ids = sale_order_obj.search(cr, uid, [('invoice_ids', 'in', [inv.id])], context=context)

                    if not isinstance(sale_order_ids, list):
                        sale_order_ids = [sale_order_ids]
                    for sale_order_id in sale_order_ids:
                        vals = {'invoice_ids': [(4, inv_id)]}
                        sale_order_obj.write(cr, uid, [sale_order_id], vals, context=context )
            
            if inv_id:
                self.button_compute(cr, uid, [inv_id], set_total=True)
                #wf_service.trg_validate(uid, 'account.invoice', inv_id, 'invoice_open', cr)
        return True
    
    # This is the first action on the invoice
    def action_date_assign(self, cr, uid, ids, *args):
        report_obj = self.pool.get('ir.actions.report.xml')
        report = report_obj.get_report(cr, uid, 'account.invoice', ids, {'ignore_state':True})
        if report and report.account_invoice_split_invoice and report.account_invoice_lines_to_split:
            self.split_invoice(cr, uid, ids, report.account_invoice_lines_to_split)

        return super(account_invoice, self).action_date_assign(cr, uid, ids, *args)
    
    def confirm_paid(self, cr, uid, ids, context=None):        
        res = super(account_invoice, self).confirm_paid(cr, uid, ids, context=context)
        self.check_sale_order_paid(cr, uid, ids, context=context)
        return res

    def check_sale_order_paid(self, cr, uid, ids, context=None):
        '''Esta funcion la hacemos para verificar si toda la orden de venta fue pagada en el caso de
         'pago antes de la entrega' porque el problema es el siguiente, de manera original openerp
         genera una factura que queda vinculada por el subflow avisando cuando fue pagada a la orden de venta, 
         el problema es que en este caso tendriamos mas de una factura ligada, por eso el chequeo hay que hacerlo aparte
         '''
        sale_order_obj = self.pool.get('sale.order')
        so_ids = sale_order_obj.search(cr, uid, [('invoice_ids', 'in', ids)], context=context)
        for so in sale_order_obj.browse(cr, uid, so_ids, context=context):
            if so.order_policy == 'prepaid' and so.invoiced:
                so.signal_workflow('subflow.paid')
        return True



















